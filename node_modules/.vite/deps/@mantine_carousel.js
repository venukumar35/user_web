import {
  EmblaCarousel
} from "./chunk-L2GABWMY.js";
import {
  AccordionChevron,
  Box,
  InlineStyles,
  UnstyledButton,
  createSafeContext,
  createVarsResolver,
  factory,
  filterProps,
  getBaseValue,
  getSortedBreakpoints,
  getSpacing,
  keys,
  rem,
  useDirection,
  useMantineTheme,
  useProps,
  useRandomClassName,
  useStyles
} from "./chunk-3ZN7SVYW.js";
import "./chunk-YI7ZP7WZ.js";
import {
  clamp
} from "./chunk-SC6YEM33.js";
import {
  require_jsx_runtime
} from "./chunk-HVLLINLV.js";
import {
  require_react
} from "./chunk-HKLPI2XQ.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/@mantine/carousel/esm/Carousel.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/embla-carousel-react/embla-carousel-react.esm.js
var import_react = __toESM(require_react());
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort(function(a, b) {
    return a.name > b.name ? 1 : -1;
  }).map(function(plugin) {
    return plugin.options;
  });
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length)
    return false;
  var areEqual = EmblaCarousel.optionsHandler().areEqual;
  var optionsA = sortAndMapPluginToOptions(pluginsA);
  var optionsB = sortAndMapPluginToOptions(pluginsB);
  return optionsA.every(function(optionA, index) {
    var optionB = optionsB[index];
    return areEqual(optionA, optionB);
  });
}
function useEmblaCarousel(options, plugins) {
  if (options === void 0) {
    options = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var optionsHandler = (0, import_react.useRef)(EmblaCarousel.optionsHandler());
  var storedOptions = (0, import_react.useRef)(options);
  var storedPlugins = (0, import_react.useRef)(plugins);
  var _a = (0, import_react.useState)(), embla = _a[0], setEmbla = _a[1];
  var _b = (0, import_react.useState)(), viewport = _b[0], setViewport = _b[1];
  var reInit = (0, import_react.useCallback)(function() {
    if (embla)
      embla.reInit(storedOptions.current, storedPlugins.current);
  }, [embla]);
  (0, import_react.useEffect)(function() {
    if (canUseDOM() && viewport) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      var newEmbla_1 = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
      setEmbla(newEmbla_1);
      return function() {
        return newEmbla_1.destroy();
      };
    } else {
      setEmbla(void 0);
    }
  }, [viewport, setEmbla]);
  (0, import_react.useEffect)(function() {
    if (optionsHandler.current.areEqual(storedOptions.current, options))
      return;
    storedOptions.current = options;
    reInit();
  }, [options, reInit]);
  (0, import_react.useEffect)(function() {
    if (arePluginsEqual(storedPlugins.current, plugins))
      return;
    storedPlugins.current = plugins;
    reInit();
  }, [plugins, reInit]);
  return [setViewport, embla];
}
useEmblaCarousel.globalOptions = void 0;

// node_modules/@mantine/carousel/esm/Carousel.context.mjs
var [CarouselProvider, useCarouselContext] = createSafeContext(
  "Carousel component was not found in tree"
);

// node_modules/@mantine/carousel/esm/CarouselSlide/CarouselSlide.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/carousel/esm/Carousel.module.css.mjs
var classes = { "root": "m_17884d0f", "viewport": "m_a2dae653", "container": "m_fcd81474", "controls": "m_39bc3463", "control": "m_64f58e10", "indicators": "m_71ea3ab1", "indicator": "m_eae68602", "slide": "m_d98df724" };

// node_modules/@mantine/carousel/esm/CarouselSlide/CarouselSlide.mjs
var defaultProps = {};
var CarouselSlide = factory((props, ref) => {
  const { classNames, className, style, styles, vars, mod, ...others } = useProps(
    "CarouselSlide",
    defaultProps,
    props
  );
  const ctx = useCarouselContext();
  return (0, import_jsx_runtime.jsx)(
    Box,
    {
      ref,
      mod: [{ orientation: ctx.orientation }, mod],
      ...ctx.getStyles("slide", { className, style, classNames, styles }),
      ...others
    }
  );
});
CarouselSlide.classes = classes;
CarouselSlide.displayName = "@mantine/carousel/CarouselSlide";

// node_modules/@mantine/carousel/esm/CarouselVariables/CarouselVariables.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function CarouselVariables({ slideGap, slideSize, selector }) {
  const theme = useMantineTheme();
  const baseStyles = filterProps({
    "--carousel-slide-gap": getSpacing(getBaseValue(slideGap)),
    "--carousel-slide-size": rem(getBaseValue(slideSize))
  });
  const queries = keys(theme.breakpoints).reduce(
    (acc, breakpoint) => {
      if (!acc[breakpoint]) {
        acc[breakpoint] = {};
      }
      if (typeof slideGap === "object" && slideGap[breakpoint] !== void 0) {
        acc[breakpoint]["--carousel-slide-gap"] = getSpacing(slideGap[breakpoint]);
      }
      if (typeof slideSize === "object" && slideSize[breakpoint] !== void 0) {
        acc[breakpoint]["--carousel-slide-size"] = getSpacing(slideSize[breakpoint]);
      }
      return acc;
    },
    {}
  );
  const sortedBreakpoints = getSortedBreakpoints(keys(queries), theme).filter(
    (breakpoint) => keys(queries[breakpoint.value]).length > 0
  );
  const media = sortedBreakpoints.map((breakpoint) => ({
    query: `(min-width: ${theme.breakpoints[breakpoint.value]})`,
    styles: queries[breakpoint.value]
  }));
  return (0, import_jsx_runtime2.jsx)(InlineStyles, { styles: baseStyles, media, selector });
}

// node_modules/@mantine/carousel/esm/get-chevron-rotation.mjs
function getChevronRotation({ dir, orientation, direction }) {
  if (direction === "previous") {
    return orientation === "horizontal" ? 90 * (dir === "ltr" ? 1 : -1) : -180;
  }
  return orientation === "horizontal" ? 90 * (dir === "ltr" ? -1 : 1) : 0;
}

// node_modules/@mantine/carousel/esm/Carousel.mjs
var defaultProps2 = {
  controlSize: 26,
  controlsOffset: "sm",
  slideSize: "100%",
  slideGap: 0,
  orientation: "horizontal",
  align: "center",
  slidesToScroll: 1,
  includeGapInSize: true,
  draggable: true,
  dragFree: false,
  loop: false,
  speed: 10,
  initialSlide: 0,
  inViewThreshold: 0,
  withControls: true,
  withIndicators: false,
  skipSnaps: false,
  containScroll: "",
  withKeyboardEvents: true
};
var varsResolver = createVarsResolver(
  (_, { height, controlSize, controlsOffset }) => ({
    root: {
      "--carousel-height": rem(height),
      "--carousel-control-size": rem(controlSize),
      "--carousel-controls-offset": getSpacing(controlsOffset)
    }
  })
);
var Carousel = factory((_props, ref) => {
  const props = useProps("Carousel", defaultProps2, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    children,
    getEmblaApi,
    onNextSlide,
    onPreviousSlide,
    onSlideChange,
    nextControlProps,
    previousControlProps,
    controlSize,
    controlsOffset,
    slideSize,
    slideGap,
    orientation,
    height,
    align,
    slidesToScroll,
    includeGapInSize,
    draggable,
    dragFree,
    loop,
    speed,
    initialSlide,
    inViewThreshold,
    withControls,
    withIndicators,
    plugins,
    nextControlIcon,
    previousControlIcon,
    skipSnaps,
    containScroll,
    withKeyboardEvents,
    mod,
    ...others
  } = props;
  const getStyles = useStyles({
    name: "Carousel",
    classes,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver
  });
  const responsiveClassName = useRandomClassName();
  const { dir } = useDirection();
  const [emblaRefElement, embla] = useEmblaCarousel(
    {
      axis: orientation === "horizontal" ? "x" : "y",
      direction: orientation === "horizontal" ? dir : void 0,
      startIndex: initialSlide,
      loop,
      align,
      slidesToScroll,
      draggable,
      dragFree,
      speed,
      inViewThreshold,
      skipSnaps,
      containScroll
    },
    plugins
  );
  const [selected, setSelected] = (0, import_react2.useState)(0);
  const [slidesCount, setSlidesCount] = (0, import_react2.useState)(0);
  const handleScroll = (0, import_react2.useCallback)((index) => embla && embla.scrollTo(index), [embla]);
  const handleSelect = (0, import_react2.useCallback)(() => {
    if (!embla)
      return;
    const slide = embla.selectedScrollSnap();
    setSelected(slide);
    onSlideChange == null ? void 0 : onSlideChange(slide);
  }, [embla, setSelected]);
  const handlePrevious = (0, import_react2.useCallback)(() => {
    embla == null ? void 0 : embla.scrollPrev();
    onPreviousSlide == null ? void 0 : onPreviousSlide();
  }, [embla]);
  const handleNext = (0, import_react2.useCallback)(() => {
    embla == null ? void 0 : embla.scrollNext();
    onNextSlide == null ? void 0 : onNextSlide();
  }, [embla]);
  const handleKeydown = (0, import_react2.useCallback)(
    (event) => {
      if (withKeyboardEvents) {
        if (event.key === "ArrowRight") {
          event.preventDefault();
          handleNext();
        }
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          handlePrevious();
        }
      }
    },
    [embla]
  );
  (0, import_react2.useEffect)(() => {
    if (embla) {
      getEmblaApi == null ? void 0 : getEmblaApi(embla);
      handleSelect();
      setSlidesCount(embla.scrollSnapList().length);
      embla.on("select", handleSelect);
      return () => {
        embla.off("select", handleSelect);
      };
    }
    return void 0;
  }, [embla, slidesToScroll]);
  (0, import_react2.useEffect)(() => {
    if (embla) {
      embla.reInit();
      setSlidesCount(embla.scrollSnapList().length);
      setSelected(
        (currentSelected) => clamp(currentSelected, 0, import_react2.Children.toArray(children).length - 1)
      );
    }
  }, [import_react2.Children.toArray(children).length, slidesToScroll]);
  const canScrollPrev = (embla == null ? void 0 : embla.canScrollPrev()) || false;
  const canScrollNext = (embla == null ? void 0 : embla.canScrollNext()) || false;
  const indicators = Array(slidesCount).fill(0).map((_, index) => (0, import_react2.createElement)(
    UnstyledButton,
    {
      ...getStyles("indicator"),
      key: index,
      "data-active": index === selected || void 0,
      "aria-hidden": true,
      tabIndex: -1,
      onClick: () => handleScroll(index),
      "data-orientation": orientation
    }
  ));
  return (0, import_jsx_runtime3.jsxs)(CarouselProvider, { value: { getStyles, orientation }, children: [
    (0, import_jsx_runtime3.jsx)(CarouselVariables, { ...props, selector: `.${responsiveClassName}` }),
    (0, import_jsx_runtime3.jsxs)(
      Box,
      {
        ref,
        ...getStyles("root", { className: responsiveClassName }),
        ...others,
        mod: [{ orientation, "include-gap-in-size": includeGapInSize }, mod],
        onKeyDownCapture: handleKeydown,
        children: [
          (0, import_jsx_runtime3.jsx)("div", { ...getStyles("viewport"), ref: emblaRefElement, children: (0, import_jsx_runtime3.jsx)("div", { ...getStyles("container"), "data-orientation": orientation, children }) }),
          withIndicators && (0, import_jsx_runtime3.jsx)("div", { ...getStyles("indicators"), "data-orientation": orientation, children: indicators }),
          withControls && (0, import_jsx_runtime3.jsxs)("div", { ...getStyles("controls"), "data-orientation": orientation, children: [
            (0, import_jsx_runtime3.jsx)(
              UnstyledButton,
              {
                ...previousControlProps,
                ...getStyles("control", {
                  className: previousControlProps == null ? void 0 : previousControlProps.className,
                  style: previousControlProps == null ? void 0 : previousControlProps.style
                }),
                onClick: (event) => {
                  var _a;
                  handlePrevious();
                  (_a = previousControlProps == null ? void 0 : previousControlProps.onClick) == null ? void 0 : _a.call(previousControlProps, event);
                },
                "data-inactive": !canScrollPrev || void 0,
                tabIndex: canScrollPrev ? 0 : -1,
                children: typeof previousControlIcon !== "undefined" ? previousControlIcon : (0, import_jsx_runtime3.jsx)(
                  AccordionChevron,
                  {
                    style: {
                      transform: `rotate(${getChevronRotation({
                        dir,
                        orientation,
                        direction: "previous"
                      })}deg)`
                    }
                  }
                )
              }
            ),
            (0, import_jsx_runtime3.jsx)(
              UnstyledButton,
              {
                ...getStyles("control", {
                  className: nextControlProps == null ? void 0 : nextControlProps.className,
                  style: nextControlProps == null ? void 0 : nextControlProps.style
                }),
                ...nextControlProps,
                onClick: (event) => {
                  var _a;
                  handleNext();
                  (_a = nextControlProps == null ? void 0 : nextControlProps.onClick) == null ? void 0 : _a.call(nextControlProps, event);
                },
                "data-inactive": !canScrollNext || void 0,
                tabIndex: canScrollNext ? 0 : -1,
                children: typeof nextControlIcon !== "undefined" ? nextControlIcon : (0, import_jsx_runtime3.jsx)(
                  AccordionChevron,
                  {
                    style: {
                      transform: `rotate(${getChevronRotation({
                        dir,
                        orientation,
                        direction: "next"
                      })}deg)`
                    }
                  }
                )
              }
            )
          ] })
        ]
      }
    )
  ] });
});
Carousel.classes = classes;
Carousel.displayName = "@mantine/carousel/Carousel";
Carousel.Slide = CarouselSlide;

// node_modules/@mantine/carousel/esm/use-animation-offset-effect.mjs
var import_react3 = __toESM(require_react(), 1);
function useAnimationOffsetEffect(embla, transitionDuration) {
  (0, import_react3.useEffect)(() => {
    if (embla) {
      window.setTimeout(() => {
        embla.reInit();
      }, transitionDuration);
    }
  }, [embla, transitionDuration]);
}
export {
  Carousel,
  CarouselSlide,
  useAnimationOffsetEffect
};
//# sourceMappingURL=@mantine_carousel.js.map
