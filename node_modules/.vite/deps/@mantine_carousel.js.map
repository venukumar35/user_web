{
  "version": 3,
  "sources": ["../../embla-carousel-react/src/components/utils.ts", "../../embla-carousel-react/src/components/index.ts", "../../@mantine/carousel/src/Carousel.context.ts", "../../@mantine/carousel/esm/Carousel.module.css.mjs", "../../@mantine/carousel/src/CarouselSlide/CarouselSlide.tsx", "../../@mantine/carousel/src/CarouselVariables/CarouselVariables.tsx", "../../@mantine/carousel/src/get-chevron-rotation.ts", "../../@mantine/carousel/src/Carousel.tsx", "../../@mantine/carousel/src/use-animation-offset-effect.ts"],
  "sourcesContent": ["import EmblaCarousel, { EmblaPluginType } from 'embla-carousel'\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[],\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[],\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const { areEqual } = EmblaCarousel.optionsHandler()\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areEqual(optionA, optionB)\n  })\n}\n", "import { useRef, useEffect, useState, useCallback } from 'react'\nimport { arePluginsEqual, canUseDOM } from './utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType,\n} from 'embla-carousel'\n\ntype EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = [],\n): UseEmblaCarouselType {\n  const optionsHandler = useRef(EmblaCarousel.optionsHandler())\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (embla) embla.reInit(storedOptions.current, storedPlugins.current)\n  }, [embla])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmbla = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current,\n      )\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, setEmbla])\n\n  useEffect(() => {\n    if (optionsHandler.current.areEqual(storedOptions.current, options)) return\n\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  return [<EmblaViewportRefType>setViewport, embla]\n}\n\nuseEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default useEmblaCarousel\n", "import { createSafeContext, GetStylesApi } from '@mantine/core';\nimport type { CarouselFactory } from './Carousel';\n\ninterface CarouselContextValue {\n  getStyles: GetStylesApi<CarouselFactory>;\n  orientation: 'horizontal' | 'vertical' | undefined;\n}\n\nexport const [CarouselProvider, useCarouselContext] = createSafeContext<CarouselContextValue>(\n  'Carousel component was not found in tree'\n);\n", "'use client';\nvar classes = {\"root\":\"m_17884d0f\",\"viewport\":\"m_a2dae653\",\"container\":\"m_fcd81474\",\"controls\":\"m_39bc3463\",\"control\":\"m_64f58e10\",\"indicators\":\"m_71ea3ab1\",\"indicator\":\"m_eae68602\",\"slide\":\"m_d98df724\"};\n\nexport { classes as default };\n//# sourceMappingURL=Carousel.module.css.mjs.map\n", "import {\n  Box,\n  BoxProps,\n  CompoundStylesApiProps,\n  ElementProps,\n  factory,\n  Factory,\n  useProps,\n} from '@mantine/core';\nimport { useCarouselContext } from '../Carousel.context';\nimport classes from '../Carousel.module.css';\n\nexport type CarouselSlideStylesNames = 'slide';\n\nexport interface CarouselSlideProps\n  extends BoxProps,\n    CompoundStylesApiProps<CarouselSlideFactory>,\n    ElementProps<'div'> {}\n\nexport type CarouselSlideFactory = Factory<{\n  props: CarouselSlideProps;\n  ref: HTMLDivElement;\n  stylesNames: CarouselSlideStylesNames;\n  compound: true;\n}>;\n\nconst defaultProps: Partial<CarouselSlideProps> = {};\n\nexport const CarouselSlide = factory<CarouselSlideFactory>((props, ref) => {\n  const { classNames, className, style, styles, vars, mod, ...others } = useProps(\n    'CarouselSlide',\n    defaultProps,\n    props\n  );\n\n  const ctx = useCarouselContext();\n\n  return (\n    <Box\n      ref={ref}\n      mod={[{ orientation: ctx.orientation }, mod]}\n      {...ctx.getStyles('slide', { className, style, classNames, styles })}\n      {...others}\n    />\n  );\n});\n\nCarouselSlide.classes = classes;\nCarouselSlide.displayName = '@mantine/carousel/CarouselSlide';\n", "import {\n  filterProps,\n  getBaseValue,\n  getSortedBreakpoints,\n  getSpacing,\n  InlineStyles,\n  keys,\n  MantineBreakpoint,\n  rem,\n  useMantineTheme,\n} from '@mantine/core';\nimport type { CarouselProps } from '../Carousel';\n\ninterface CarouselVariablesProps extends CarouselProps {\n  selector: string;\n}\n\nexport function CarouselVariables({ slideGap, slideSize, selector }: CarouselVariablesProps) {\n  const theme = useMantineTheme();\n\n  const baseStyles: Record<string, string | undefined> = filterProps({\n    '--carousel-slide-gap': getSpacing(getBaseValue(slideGap)),\n    '--carousel-slide-size': rem(getBaseValue(slideSize)),\n  });\n\n  const queries = keys(theme.breakpoints).reduce<Record<string, Record<string, any>>>(\n    (acc, breakpoint) => {\n      if (!acc[breakpoint]) {\n        acc[breakpoint] = {};\n      }\n\n      if (typeof slideGap === 'object' && slideGap[breakpoint] !== undefined) {\n        acc[breakpoint]['--carousel-slide-gap'] = getSpacing(slideGap[breakpoint]);\n      }\n\n      if (typeof slideSize === 'object' && slideSize[breakpoint] !== undefined) {\n        acc[breakpoint]['--carousel-slide-size'] = getSpacing(slideSize[breakpoint]);\n      }\n\n      return acc;\n    },\n    {}\n  );\n\n  const sortedBreakpoints = getSortedBreakpoints(keys(queries), theme).filter(\n    (breakpoint) => keys(queries[breakpoint.value]).length > 0\n  );\n\n  const media = sortedBreakpoints.map((breakpoint) => ({\n    query: `(min-width: ${theme.breakpoints[breakpoint.value as MantineBreakpoint]})`,\n    styles: queries[breakpoint.value],\n  }));\n\n  return <InlineStyles styles={baseStyles} media={media} selector={selector} />;\n}\n", "interface Options {\n  dir: 'rtl' | 'ltr';\n  orientation: 'horizontal' | 'vertical' | undefined;\n  direction: 'next' | 'previous';\n}\n\nexport function getChevronRotation({ dir, orientation, direction }: Options) {\n  if (direction === 'previous') {\n    return orientation === 'horizontal' ? 90 * (dir === 'ltr' ? 1 : -1) : -180;\n  }\n\n  return orientation === 'horizontal' ? 90 * (dir === 'ltr' ? -1 : 1) : 0;\n}\n", "import { Children, useCallback, useEffect, useState } from 'react';\nimport useEmblaCarousel, { EmblaCarouselType, EmblaPluginType } from 'embla-carousel-react';\nimport {\n  AccordionChevron,\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  getSpacing,\n  MantineSpacing,\n  rem,\n  StyleProp,\n  StylesApiProps,\n  UnstyledButton,\n  useDirection,\n  useProps,\n  useRandomClassName,\n  useStyles,\n} from '@mantine/core';\nimport { clamp } from '@mantine/hooks';\nimport { CarouselProvider } from './Carousel.context';\nimport { CarouselSlide } from './CarouselSlide/CarouselSlide';\nimport { CarouselVariables } from './CarouselVariables/CarouselVariables';\nimport { getChevronRotation } from './get-chevron-rotation';\nimport classes from './Carousel.module.css';\n\nexport type CarouselStylesNames =\n  | 'slide'\n  | 'root'\n  | 'viewport'\n  | 'container'\n  | 'controls'\n  | 'control'\n  | 'indicators'\n  | 'indicator';\n\nexport type CarouselCssVariables = {\n  root: '--carousel-height' | '--carousel-control-size' | '--carousel-controls-offset';\n};\n\nexport interface CarouselProps\n  extends BoxProps,\n    StylesApiProps<CarouselFactory>,\n    ElementProps<'div'> {\n  /** <Carousel.Slide /> components */\n  children?: React.ReactNode;\n\n  /** Called when next slide is shown */\n  onNextSlide?: () => void;\n\n  /** Called when previous slider is shown */\n  onPreviousSlide?: () => void;\n\n  /** Called with slide index when slide changes */\n  onSlideChange?: (index: number) => void;\n\n  /** Get embla API as ref */\n  getEmblaApi?: (embla: EmblaCarouselType) => void;\n\n  /** Props passed down to next control */\n  nextControlProps?: React.ComponentPropsWithoutRef<'button'>;\n\n  /** Props passed down to previous control */\n  previousControlProps?: React.ComponentPropsWithoutRef<'button'>;\n\n  /** Controls size of the next and previous controls, `26` by default */\n  controlSize?: React.CSSProperties['width'];\n\n  /** Controls position of the next and previous controls, key of `theme.spacing` or any valid CSS value, `'sm'` by default */\n  controlsOffset?: MantineSpacing;\n\n  /** Controls slide width based on viewport width, `'100%'` by default */\n  slideSize?: StyleProp<string | number>;\n\n  /** Key of theme.spacing or number to set gap between slides */\n  slideGap?: StyleProp<MantineSpacing>;\n\n  /** Carousel orientation, `'horizontal'` by default */\n  orientation?: 'horizontal' | 'vertical';\n\n  /** Slides container `height`, required for vertical orientation */\n  height?: React.CSSProperties['height'];\n\n  /** Determines how slides will be aligned relative to the container. Use number between 0-1 to align slides based on percentage, where 0.5 is 50%, `'center'` by default */\n  align?: 'start' | 'center' | 'end' | number;\n\n  /** Number of slides that will be scrolled with next/previous buttons, `1` by default */\n  slidesToScroll?: number | 'auto';\n\n  /** Determines whether gap between slides should be treated as part of the slide size, `true` by default */\n  includeGapInSize?: boolean;\n\n  /** Determines whether the carousel can be scrolled with mouse and touch interactions, `true` by default */\n  draggable?: boolean;\n\n  /** Determines whether momentum scrolling should be enabled, `false` by default */\n  dragFree?: boolean;\n\n  /** Enables infinite looping. `true` by default, automatically falls back to `false` if slide content isn't enough to loop. */\n  loop?: boolean;\n\n  /** Adjusts scroll speed when triggered by any of the methods. Higher numbers enables faster scrolling. */\n  speed?: number;\n\n  /** Index of initial slide */\n  initialSlide?: number;\n\n  /** Choose a fraction representing the percentage portion of a slide that needs to be visible in order to be considered in view. For example, 0.5 equals 50%. */\n  inViewThreshold?: number;\n\n  /** Determines whether next/previous controls should be displayed, true by default */\n  withControls?: boolean;\n\n  /** Determines whether indicators should be displayed, `false` by default */\n  withIndicators?: boolean;\n\n  /** An array of embla plugins */\n  plugins?: EmblaPluginType[];\n\n  /** Icon of the next control */\n  nextControlIcon?: React.ReactNode;\n\n  /** Icon of the previous control */\n  previousControlIcon?: React.ReactNode;\n\n  /** Allow the carousel to skip scroll snaps if it is dragged vigorously. Note that this option will be ignored if the dragFree option is set to `true`, `false` by default */\n  skipSnaps?: boolean;\n\n  /** Clear leading and trailing empty space that causes excessive scrolling. Use `trimSnaps` to only use snap points that trigger scrolling or keepSnaps to keep them. */\n  containScroll?: 'trimSnaps' | 'keepSnaps' | '';\n\n  /** Determines whether arrow key should switch slides, `true` by default */\n  withKeyboardEvents?: boolean;\n}\n\nexport type CarouselFactory = Factory<{\n  props: CarouselProps;\n  ref: HTMLDivElement;\n  stylesNames: CarouselStylesNames;\n  vars: CarouselCssVariables;\n  staticComponents: {\n    Slide: typeof CarouselSlide;\n  };\n}>;\n\nconst defaultProps: Partial<CarouselProps> = {\n  controlSize: 26,\n  controlsOffset: 'sm',\n  slideSize: '100%',\n  slideGap: 0,\n  orientation: 'horizontal',\n  align: 'center',\n  slidesToScroll: 1,\n  includeGapInSize: true,\n  draggable: true,\n  dragFree: false,\n  loop: false,\n  speed: 10,\n  initialSlide: 0,\n  inViewThreshold: 0,\n  withControls: true,\n  withIndicators: false,\n  skipSnaps: false,\n  containScroll: '',\n  withKeyboardEvents: true,\n};\n\nconst varsResolver = createVarsResolver<CarouselFactory>(\n  (_, { height, controlSize, controlsOffset }) => ({\n    root: {\n      '--carousel-height': rem(height),\n      '--carousel-control-size': rem(controlSize),\n      '--carousel-controls-offset': getSpacing(controlsOffset),\n    },\n  })\n);\n\nexport const Carousel = factory<CarouselFactory>((_props, ref) => {\n  const props = useProps('Carousel', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    children,\n    getEmblaApi,\n    onNextSlide,\n    onPreviousSlide,\n    onSlideChange,\n    nextControlProps,\n    previousControlProps,\n    controlSize,\n    controlsOffset,\n    slideSize,\n    slideGap,\n    orientation,\n    height,\n    align,\n    slidesToScroll,\n    includeGapInSize,\n    draggable,\n    dragFree,\n    loop,\n    speed,\n    initialSlide,\n    inViewThreshold,\n    withControls,\n    withIndicators,\n    plugins,\n    nextControlIcon,\n    previousControlIcon,\n    skipSnaps,\n    containScroll,\n    withKeyboardEvents,\n    mod,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<CarouselFactory>({\n    name: 'Carousel',\n    classes,\n    props,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  const responsiveClassName = useRandomClassName();\n  const { dir } = useDirection();\n\n  const [emblaRefElement, embla] = useEmblaCarousel(\n    {\n      axis: orientation === 'horizontal' ? 'x' : 'y',\n      direction: orientation === 'horizontal' ? dir : undefined,\n      startIndex: initialSlide,\n      loop,\n      align,\n      slidesToScroll,\n      draggable,\n      dragFree,\n      speed,\n      inViewThreshold,\n      skipSnaps,\n      containScroll,\n    },\n    plugins\n  );\n\n  const [selected, setSelected] = useState(0);\n  const [slidesCount, setSlidesCount] = useState(0);\n\n  const handleScroll = useCallback((index: number) => embla && embla.scrollTo(index), [embla]);\n\n  const handleSelect = useCallback(() => {\n    if (!embla) return;\n    const slide = embla.selectedScrollSnap();\n    setSelected(slide);\n    onSlideChange?.(slide);\n  }, [embla, setSelected]);\n\n  const handlePrevious = useCallback(() => {\n    embla?.scrollPrev();\n    onPreviousSlide?.();\n  }, [embla]);\n\n  const handleNext = useCallback(() => {\n    embla?.scrollNext();\n    onNextSlide?.();\n  }, [embla]);\n\n  const handleKeydown = useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (withKeyboardEvents) {\n        if (event.key === 'ArrowRight') {\n          event.preventDefault();\n          handleNext();\n        }\n\n        if (event.key === 'ArrowLeft') {\n          event.preventDefault();\n          handlePrevious();\n        }\n      }\n    },\n    [embla]\n  );\n\n  useEffect(() => {\n    if (embla) {\n      getEmblaApi?.(embla);\n      handleSelect();\n      setSlidesCount(embla.scrollSnapList().length);\n      embla.on('select', handleSelect);\n\n      return () => {\n        embla.off('select', handleSelect);\n      };\n    }\n\n    return undefined;\n  }, [embla, slidesToScroll]);\n\n  useEffect(() => {\n    if (embla) {\n      embla.reInit();\n      setSlidesCount(embla.scrollSnapList().length);\n      setSelected((currentSelected) =>\n        clamp(currentSelected, 0, Children.toArray(children).length - 1)\n      );\n    }\n  }, [Children.toArray(children).length, slidesToScroll]);\n\n  const canScrollPrev = embla?.canScrollPrev() || false;\n  const canScrollNext = embla?.canScrollNext() || false;\n\n  const indicators = Array(slidesCount)\n    .fill(0)\n    .map((_, index) => (\n      <UnstyledButton\n        {...getStyles('indicator')}\n        key={index}\n        data-active={index === selected || undefined}\n        aria-hidden\n        tabIndex={-1}\n        onClick={() => handleScroll(index)}\n        data-orientation={orientation}\n      />\n    ));\n\n  return (\n    <CarouselProvider value={{ getStyles, orientation }}>\n      <CarouselVariables {...props} selector={`.${responsiveClassName}`} />\n      <Box\n        ref={ref}\n        {...getStyles('root', { className: responsiveClassName })}\n        {...others}\n        mod={[{ orientation, 'include-gap-in-size': includeGapInSize }, mod]}\n        onKeyDownCapture={handleKeydown}\n      >\n        <div {...getStyles('viewport')} ref={emblaRefElement}>\n          <div {...getStyles('container')} data-orientation={orientation}>\n            {children}\n          </div>\n        </div>\n\n        {withIndicators && (\n          <div {...getStyles('indicators')} data-orientation={orientation}>\n            {indicators}\n          </div>\n        )}\n\n        {withControls && (\n          <div {...getStyles('controls')} data-orientation={orientation}>\n            <UnstyledButton\n              {...previousControlProps}\n              {...getStyles('control', {\n                className: previousControlProps?.className,\n                style: previousControlProps?.style,\n              })}\n              onClick={(event) => {\n                handlePrevious();\n                previousControlProps?.onClick?.(event);\n              }}\n              data-inactive={!canScrollPrev || undefined}\n              tabIndex={canScrollPrev ? 0 : -1}\n            >\n              {typeof previousControlIcon !== 'undefined' ? (\n                previousControlIcon\n              ) : (\n                <AccordionChevron\n                  style={{\n                    transform: `rotate(${getChevronRotation({\n                      dir,\n                      orientation,\n                      direction: 'previous',\n                    })}deg)`,\n                  }}\n                />\n              )}\n            </UnstyledButton>\n\n            <UnstyledButton\n              {...getStyles('control', {\n                className: nextControlProps?.className,\n                style: nextControlProps?.style,\n              })}\n              {...nextControlProps}\n              onClick={(event) => {\n                handleNext();\n                nextControlProps?.onClick?.(event);\n              }}\n              data-inactive={!canScrollNext || undefined}\n              tabIndex={canScrollNext ? 0 : -1}\n            >\n              {typeof nextControlIcon !== 'undefined' ? (\n                nextControlIcon\n              ) : (\n                <AccordionChevron\n                  style={{\n                    transform: `rotate(${getChevronRotation({\n                      dir,\n                      orientation,\n                      direction: 'next',\n                    })}deg)`,\n                  }}\n                />\n              )}\n            </UnstyledButton>\n          </div>\n        )}\n      </Box>\n    </CarouselProvider>\n  );\n});\n\nCarousel.classes = classes;\nCarousel.displayName = '@mantine/carousel/Carousel';\nCarousel.Slide = CarouselSlide;\n", "import { useEffect } from 'react';\nimport type { EmblaCarouselType } from 'embla-carousel-react';\n\nexport function useAnimationOffsetEffect(\n  embla: EmblaCarouselType | null | undefined,\n  transitionDuration: number\n) {\n  useEffect(() => {\n    if (embla) {\n      window.setTimeout(() => {\n        embla.reInit();\n      }, transitionDuration);\n    }\n  }, [embla, transitionDuration]);\n}\n"],
  "mappings": "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",
  "names": ["canUseDOM", "window", "document", "createElement", "sortAndMapPluginToOptions", "plugins", "concat", "sort", "a", "b", "name", "map", "plugin", "options", "arePluginsEqual", "pluginsA", "pluginsB", "length", "areEqual", "EmblaCarousel", "optionsHandler", "optionsA", "optionsB", "every", "optionA", "index", "optionB", "useEmblaCarousel", "useRef", "storedOptions", "storedPlugins", "_a", "useState", "embla", "setEmbla", "_b", "viewport", "setViewport", "reInit", "useCallback", "current", "useEffect", "globalOptions", "newEmbla_1", "destroy", "undefined", "defaultProps"]
}
